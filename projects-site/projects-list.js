export const projects = [
    {
        projectID: "kjshdf031ka",
        projectName: "Wisielec The Game",
        thumbnailPath: "../assets/projects-photos/wisielec.PNG",
        thumbnailMobilePath: "../assets/projects-photos/wisielec-mobile.png",
        description: 'The game "Hangman" is a classic word game where the goal is to guess a hidden word by suggesting letters. In the C version, the Standard Template Library (STL) is used to manage data structures such as vectors and maps. Instead of traditional images depicting the hangman, the game uses bitmaps displayed in the console to represent the various stages of gameplay. The STL also facilitates handling game-related data, such as correctly and incorrectly guessed letters. As a result, the project is easy to maintain and flexible for further development.',
        readMoreLink: "#",
        downloadFile: "213213",
        technologies: "C",
    }, 
    {
        projectID: "hsalkjg9021",
        projectName: "Sorting Algorithms",
        thumbnailPath: "../assets/projects-photos/sorting.PNG",
        thumbnailMobilePath: "../assets/projects-photos/sorting-mobile.png",
        description: "Analysis of the computational complexity of six popular sorting algorithms: Bubble, Insertion, Selection, Quick, Merge, and Heap sort. They are presented in the context of different types of data, such as random, increasing, decreasing, and shapes A and V. Their performance is discussed in the best, average, and worst cases, along with charts illustrating execution time based on input data. Quick sort, while regarded as the fastest, does not always perform the best. Full data is available in the Excel spreadsheet.",
        readMoreLink: "project-folder/sortingAlgorithms/sortowania.pdf",
        downloadFile: "#",
        technologies: "Python",
    },    
    {
        projectID: "odkjfhas284",
        projectName: "Binary Search Trees",
        thumbnailPath: "../assets/projects-photos/bst.png",
        thumbnailMobilePath: "../assets/projects-photos/bst-mobile.png",
        description: "Investigation and comparison of the performance of BST (Binary Search Trees) and AVL trees using randomly generated data. The code implements functions for insertion, deletion, searching, and balancing the tree, with recursive balancing applied specifically for AVL trees. The analysis covers the time complexity of operations on both tree types, along with graphs depicting time dependencies for insertion, searching, and printing elements.",
        readMoreLink: "project-folder/bst/bst.pdf",
        downloadFile: "#",
        technologies: "Python",
    },   
    {
        projectID: "slpiodsjf23",
        projectName: "DFS and KHAN graph algorithms",
        thumbnailPath: "../assets/projects-photos/graf.png",
        thumbnailMobilePath: "../assets/projects-photos/khandfs-mobile.png",
        description: "Analysis and Comparison of DFS and KHAN Graph Algorithms on Graph and Adjacency Matrices, Generated with 50% Edge Saturation. The computational and time complexity of the algorithms were examined, and graphs showing the time dependency on the number of vertices were created. For the graph matrix, optimized lists of successors, predecessors, and incidences were applied, improving performance. The adjacency matrix, on the other hand, allowed for fast edge checking but at the cost of higher memory complexity. The DFS algorithm proved to be faster due to fewer operations compared to KHAN, which requires constant updates of vertex degrees. Detailed results and test outcomes are presented in the charts.",
        readMoreLink: "project-folder/dfskhanAlgorithm/dfskhan.pdf",
        downloadFile: "#",
        technologies: "Python",
    },   
    {
        projectID: "lkdsjhfkj12",
        projectName: "Finding Euler and Hamilton Cycles",
        thumbnailPath: "../assets/projects-photos/matrix.png",
        thumbnailMobilePath: "../assets/projects-photos/matrix-mobile.png",
        description: "Study of Computational Complexity and Performance of Euler and Hamiltonian Cycle Algorithms in Directed and Undirected Graphs. An analysis of the efficiency of two graph representations: adjacency matrices and successor lists. The algorithms were tested on data from text files, comparing their execution time depending on the number of vertices and the graph's edge density. The results indicate that successor lists are more memory-efficient for sparse graphs, while adjacency matrices perform better in dense graphs. The Euler cycle algorithm has lower computational complexity compared to the Hamiltonian cycle, which belongs to NP-complete problems. The algorithms and their complexity were presented in the form of charts, allowing for a clear analysis of the results.",
        readMoreLink: "project-folder/eulerHamiltonCycles/hamiltonEuler.pdf",
        downloadFile: "#",
        technologies: "Python",
    },  
    {
        projectID: "1dkjfgmlkb9",
        projectName: "knapsack problem",
        thumbnailPath: "../assets/projects-photos/backpack.png",
        thumbnailMobilePath: "../assets/projects-photos/knapsack-mobile.png",
        description: "The knapsack problem is a classic optimization challenge focused on maximizing the value of items selected for a backpack with a given capacity. This report discusses three algorithms for solving this problem: dynamic programming, greedy, and brute force. The dynamic programming algorithm provides an optimal solution, but its computation time increases depending on the number of items and the backpack's capacity. The greedy algorithm is fast and simple, but it doesn't always guarantee the best result. The brute force algorithm, while accurate, becomes inefficient for large data sets due to its exponential time complexity.",
        readMoreLink: "#",
        downloadFile: "#",
        technologies: "Python",
    },  
];